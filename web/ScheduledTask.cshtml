@using WebMatrix.Data;
@using System.Text;
@{
    var logger = new LcLogger("ScheduledTask");
    var elapsedTime = DateTime.Now;
    
    /*
     * Bookings
     */

    int messages = 0, items = 0;
    int totalmessages = 0, totalitems = 0;
    
    var sqlAddBookingRequestMessagingLog = "UPDATE BookingRequest SET MessagingLog = coalesce(MessagingLog, '') + @1 WHERE BookingRequestID=@0";
    var sqlAddBookingMessagingLog = "UPDATE Booking SET MessagingLog = coalesce(MessagingLog, '') + @1 WHERE BookingID=@0";
    
    using(var db = Database.Open("sqlloco")){
        /*
         * Check:: Booking Request timed out
         * If:: A not complete booking request exist without changes from more than 1 day
         * Action:: Set as timedout, invalidating the request and its data
         */
        messages = 0;
        items = 0;
        foreach (var br in db.Query(@"
                SELECT  BookingRequestID
                FROM    BookingRequest
                WHERE   BookingRequestStatusID = 1 -- created but not completed
                         AND
                        -- is old enought to be considered not active
                        UpdatedDate < dateadd(d, -1, getdate())
            ")){
            try {
                // RequestStatusID:3:timed out
                LcData.Booking.InvalidateBookingRequest(br.BookingRequestID, 3);

                items++;
            } catch (Exception ex){
                logger.LogEx("Requests Timed-out", ex);
            }
        }
        logger.Log("Total invalidated as TimedOut Booking Requests: {0}, messages sent: {1}", items, messages);
        totalitems += items;
        totalmessages += messages;
        
        /*
         * Check:: Booking Request expiration
         * If:: Provider didn't reply
         * If:: Request not updated/changed
         * Action:: Set as expired, un-authorize/return money to customer, notify
         */
        messages = 0;
        items = 0;
        foreach (var br in db.Query(@"
                SELECT  BookingRequestID
                FROM    BookingRequest
                WHERE   BookingRequestStatusID = 2 -- request created and completed, without provider answer
                         AND
                        -- passed x hours from request or some change (some provider communication or customer change)
                        UpdatedDate < dateadd(hh, 0 - @0, getdate())
            ", LcData.Booking.ConfirmationLimitInHours)){
            try {
                // RequestStatusID:6:expired
                var result = LcData.Booking.InvalidateBookingRequest(br.BookingRequestID, 6);
                if (result.Error == 0) {
                    // Send message
                    LcMessaging.SendBookingRequestInvalidation(br.BookingRequestID, 1, 19);
                    
                    // Update MessagingLog for the booking request
                    db.Execute(sqlAddBookingRequestMessagingLog, br.BookingRequestID, "[Booking Request Expiration]");
                }
                
                items++;
                messages += 2;
            } catch (Exception ex){
                logger.LogEx("Requests Expired", ex);
            }
        }
        logger.Log("Total invalidated as Expired Booking Requests: {0}, messages sent: {1}", items, messages);
        totalitems += items;
        totalmessages += messages;
        
        /*
         * Check:: [24H Service Reminder] Booking will be on 24Hours
         * If:: Confirmated bookings not cancelled
         * If:: Current time is 24 hours before Confirmed Service StarTime
         * Action:: send a booking reminder email
         */
        messages = 0;
        items = 0;
        foreach (var b in db.Query(@"
                SELECT  BookingID
                FROM    Booking As B
                         INNER JOIN
                        CalendarEvents As E
                          ON B.ConfirmedDateID = E.Id
                WHERE   BookingStatusID = 1 -- confirmed, not cancelled and not other changes
                         AND
                        -- at 24 hours before service starts (between 25 and 24 hours)
                        getdate() > dateadd(hh, -25, E.StartTime)
                         AND
                        getdate() <= dateadd(hh, -24, E.StartTime)
                         AND
                        B.MessagingLog not like '%[24H Service Reminder]%'
            ")){
            try {
                // Send message
                LcMessaging.SendBookingUpdate(b.BookingID, 's', 'b', "service");
                
                // Update MessagingLog for the booking
                db.Execute(sqlAddBookingMessagingLog, b.BookingID, "[24H Service Reminder]");

                items++;
                messages += 2;
            } catch (Exception ex){
                logger.LogEx("Booking 24H Reminders", ex);
            }
        }
        logger.Log("Total of Booking 24H Reminders: {0}, messages sent: {1}", items, messages);
        totalitems += items;
        totalmessages += messages;
        
        /*
         * Check:: [8AM Review Reminder] Booking Review Reminder Next day after service at 8AM
         * If:: Confirmed bookings not cancelled
         * If:: User did not the review still
         * If:: Current time is 8AM on the day after the Confirmed Service EndTime
         * Action:: send a booking review reminder email
         */
        messages = 0;
        items = 0;
        foreach (var b in db.Query(@"
                SELECT  B.BookingID,
                        CAST(CASE WHEN (SELECT count(*) FROM UserReviews As URP
                            WHERE URP.BookingID = B.BookingID
                                AND
                                URP.ProviderUserID = R.ProviderUserID
                                AND 
                                URP.PositionID = 0
                        ) = 0 THEN 0 ELSE 1 END As bit) As ReviewedByProvider,
                        CAST(CASE WHEN (SELECT count(*) FROM UserReviews As URC
                            WHERE URC.BookingID = B.BookingID
                                AND
                                URC.CustomerUserID = R.CustomerUserID
                                AND 
                                URC.PositionID = R.PositionID
                        ) = 0 THEN 0 ELSE 1 END As bit) As ReviewedByCustomer
                FROM    BookingRequest As R
                         INNER JOIN
                        Booking As B
                          ON R.BookingRequestID = B.BookingRequestID
                         INNER JOIN
                        CalendarEvents As E
                          ON B.ConfirmedDateID = E.Id
                WHERE   B.BookingStatusID = 1 -- confirmed, not cancelled and not other changes
                         AND
                        -- at 8AM hours
                        datepart(hh, getdate()) = 8
                         AND
                        -- of the day after the service
                        Cast(dateadd(d, -1, getdate()) As Date) = Cast(E.EndTime As Date)
                         AND
                        B.MessagingLog not like '%[8AM Review Reminder]%'
            ")){
            try {
                // We need check that there was not reviews already (why send a reminder for something
                // already done? just we avoid that!).
                // If both users did its reviews, nothing to send
                if (b.ReviewedByProvider && b.ReviewedByCustomer) {
                    // Next booking
                    continue;
                }
                char messageFor = 
                    b.ReviewedByProvider ? 'c' : 
                    b.ReviewedByCustomer ? 'p' : 
                    'b';

                // Send message
                LcMessaging.SendBookingUpdate(b.BookingID, 's', messageFor, "review-firstreminder");
                
                // Update MessagingLog for the booking
                db.Execute(sqlAddBookingMessagingLog, b.BookingID, "[8AM Review Reminder]");

                items++;
                if (messageFor == 'c' || messageFor == 'p') {
                    messages++;
                } else {
                    messages+=2;
                }
            } catch (Exception ex){
                logger.LogEx("Booking Review Reminders Next 8AM", ex);
            }
        }
        logger.Log("Total of Booking Review Reminders Next 8AM: {0}, messages sent: {1}", items, messages);
        totalitems += items;
        totalmessages += messages;
        
        /*
         * Check:: [1W Review Reminder] Booking Review Reminder 1Week after service
         * If:: Confirmed bookings not cancelled, non stoped manully, maybe is set as performed already
         * If:: User did not the review still
         * If:: Past 1 Week from service
         * Action:: send a booking review reminder email
         */
        messages = 0;
        items = 0;
        foreach (var b in db.Query(@"
                SELECT  B.BookingID,
                        CAST(CASE WHEN (SELECT count(*) FROM UserReviews As URP
                            WHERE URP.BookingID = B.BookingID
                                AND
                                URP.ProviderUserID = R.ProviderUserID
                                AND 
                                URP.PositionID = 0
                        ) = 0 THEN 0 ELSE 1 END As bit) As ReviewedByProvider,
                        CAST(CASE WHEN (SELECT count(*) FROM UserReviews As URC
                            WHERE URC.BookingID = B.BookingID
                                AND
                                URC.CustomerUserID = R.CustomerUserID
                                AND 
                                URC.PositionID = R.PositionID
                        ) = 0 THEN 0 ELSE 1 END As bit) As ReviewedByCustomer
                FROM    BookingRequest As R
                         INNER JOIN
                        Booking As B
                          ON R.BookingRequestID = B.BookingRequestID
                         INNER JOIN
                        CalendarEvents As E
                          ON B.ConfirmedDateID = E.Id
                WHERE   B.BookingStatusID IN (
                            1 -- confirmed, not cancelled and not other changes
                            ,2, 3 -- service performed, with or without pricing adjustment
                            ,4 -- completed, service and payment done
                        )
                         AND
                        -- at 1 Week=168 hours, after service ended (between 168 and 175 hours -6 hours of margin-)
                        getdate() >= dateadd(hh, 168, E.EndTime)
                         AND
                        getdate() < dateadd(hh, 175, E.EndTime)
                         AND
                        B.MessagingLog not like '%[1W Review Reminder]%'
            ")){
            try {
                // We need check that there was not reviews already (why send a reminder for something
                // already done? just we avoid that!).
                // If both users did its reviews, nothing to send
                if (b.ReviewedByProvider && b.ReviewedByCustomer) {
                    // Next booking
                    continue;
                }
                char messageFor = 
                    b.ReviewedByProvider ? 'c' : 
                    b.ReviewedByCustomer ? 'p' : 
                    'b';

                // Send message
                LcMessaging.SendBookingUpdate(b.BookingID, 's', messageFor, "review");
                
                // Update MessagingLog for the booking
                db.Execute(sqlAddBookingMessagingLog, b.BookingID, "[1W Review Reminder]");
                
                items++;
                if (messageFor == 'c' || messageFor == 'p') {
                    messages++;
                } else {
                    messages+=2;
                }
            } catch (Exception ex){
                logger.LogEx("Booking Review Reminders 1W", ex);
            }
        }
        logger.Log("Total of Booking Review Reminders 1W: {0}, messages sent: {1}", items, messages);
        totalitems += items;
        totalmessages += messages;
        
        /*
         * Check:: Service Performed: 48H passed from Service
         * If:: Confirmated bookings only, not cancelled, not set as performed, complete or dispute
         * If:: Current time is 48 hours after Confirmed Service EndTime
         * Action:: set booking status as 'performed without pricing adjustment',
         *          // Not with Marketplace: send a message to Loconomics Stuff Users requesting manual payment to provider,
         *          and a message to customer and provider notifying that booking is set as 'performed'.
         */
        messages = 0;
        items = 0;
        {
            // Get bookings affected by conditions
            var sqlGet = @"
                SELECT  BookingID
                FROM    Booking As B
                         INNER JOIN
                        CalendarEvents As E
                          ON B.ConfirmedDateID = E.Id
                WHERE   BookingStatusID = 1 -- confirmed, not cancelled and not other changes
                         AND
                        -- at 48 hours after service ended (more than 48 hours is fine)
                        getdate() >= dateadd(hh, 48, E.EndTime)
                        /* AND
                         getdate() < dateadd(hh, 49, E.EndTime)
                        */
            ";
            var bookings = db.Query(sqlGet);
            // Update bookings affected by conditions to 
            // StatusID:2, performed without pricing adjustment.
            // We do this operation as a unique SQL operation because is faster than performs
            // it per booking in the loop.
            db.Execute(@"
                UPDATE  Booking
                SET     BookingStatusID = 2
                        ,UpdatedDate = getdate()
                WHERE   BookingID IN (
            " + sqlGet + 
            " ) ");
            
            foreach (var b in bookings){
                try {               
                    // Send messages
                    
                    // With Braintree Marketplace, this is not need:
                    // Notify Loconomics Staff Users requesting 
                    // the manual payment and other tasks:
                    //LcMessaging.SendProviderPaymentRequestToLoconomics(b.BookingID);
                    
                    // Notify customer and provider with an updated booking details:
                    LcMessaging.SendBookingUpdate(b.BookingID, 's');
                    
                    // Update MessagingLog for the booking
                    db.Execute(sqlAddBookingMessagingLog, b.BookingID, "[48H Service Performed]");

                    items++;
                    // Before Marketplace: messages += 3;
                    messages += 2;
                } catch (Exception ex){
                    logger.LogEx("Booking 48H Service Performed", ex);
                }
            }
        }
        logger.Log("Total of Booking 48H Service Performed: {0}, messages sent: {1}", items, messages);
        totalitems += items;
        totalmessages += messages;
        
        /*
         * Check:: Release Payment for New Providers: 5 full days after the service is performed
         * If:: If provider is a new provider (it has not previous completed bookings)
         * If:: Performed bookings only, without pricing adjustment
         * If:: Current time is 5 days after Confirmed Service EndTime
         * Action:: set booking status as 'performed without pricing adjustment',
         *          send a message to the provider notifying that payment is released.
         */
        messages = 0;
        items = 0;
        {
            // Get bookings affected by conditions
            var sqlGet = @"
                SELECT  B.BookingID
                        ,BR.PaymentTransactionID
                FROM    Booking As B
                         INNER JOIN
                        CalendarEvents As E
                          ON B.ConfirmedDateID = E.Id
                         INNER JOIN
                        BookingRequest As BR
                          ON BR.BookingRequestID = B.BookingRequestID
                WHERE   BookingStatusID = 2 -- performed without pricing adjustment, not cancelled and not other changes
                         AND
                        -- at 120 hours, 5 days, after service ended (more than that is fine)
                        getdate() >= dateadd(hh, 120, E.EndTime)
                        /* AND
                         getdate() < dateadd(hh, 121, E.EndTime)
                        */
                         AND
                        (SELECT count(*)
                         FROM Booking As B2 INNER JOIN BookingRequest As BR2 ON BR2.BookingRequestID = B2.BookingRequestID
                         WHERE
                            BR2.ProviderUserID = BR.ProviderUserID
                             AND
                            B2.BookingStatusID = 4 --Complete bookings
                        ) = 0 -- There is no complete bookings
            ";
            var bookings = db.Query(sqlGet);

            foreach (var b in bookings){
                try {
                    // Release the payment
                    var errmsg = LcPayment.ReleaseTransactionFromEscrow(b.PaymentTransactionID);
                    
                    if (errmsg == null) {
                        // Mark as payed (StatusID:4 'complete')
                        db.Execute(@"
                            UPDATE  Booking
                            SET     BookingStatusID = 4
                                    ,UpdatedDate = getdate()
                            WHERE   BookingID = @0", b.BookingID);
                    
                        // Send messages
                    
                        // Notify customer and provider with an updated booking details:
                        LcMessaging.SendBookingUpdate(b.BookingID, 's');
                    
                        // Update MessagingLog for the booking
                        db.Execute(sqlAddBookingMessagingLog, b.BookingID, "[Release Payment 120H New Provider]");

                        items++;
                        messages += 2;
                    }
                    else {
                        
                        var errTitle = "Booking Release Payment after 120H for new providers";
                        var errDesc = String.Format(
                            "BookingID: {0}, TransactionID: {1} Not payed, error on Braintree 'release transaction from escrow': {2}",
                            b.BookingID,
                            b.PaymentTransactionID,
                            errmsg
                        );
                        
                        LcMessaging.NotifyError(errTitle, "/ScheduleTask", errDesc);
                        
                        logger.Log("Error on: " + errTitle + "; " + errDesc);
                    }
                } catch (Exception ex){
                    logger.LogEx("Booking Release Payment after 120H for new providers", ex);
                }
            }
        }
        logger.Log("Total of Booking Release Payment after 120H for new providers: {0}, messages sent: {1}", items, messages);
        totalitems += items;
        totalmessages += messages;
        
        
        /*
         * Check:: Release Payment for Service Complete: 1 day after the service is performed
         * If:: Provider has already completed bookings (is not a new provider)
         * If:: Performed bookings only, without pricing adjustment
         * If:: Current time is 5 days after Confirmed Service EndTime
         * Action:: set booking status as 'performed without pricing adjustment',
         *          send a message to the provider notifying that payment is released.
         */
        messages = 0;
        items = 0;
        {
            // Get bookings affected by conditions
            var sqlGet = @"
                SELECT  B.BookingID
                        ,BR.PaymentTransactionID
                FROM    Booking As B
                         INNER JOIN
                        CalendarEvents As E
                          ON B.ConfirmedDateID = E.Id
                         INNER JOIN
                        BookingRequest As BR
                          ON BR.BookingRequestID = B.BookingRequestID
                WHERE   BookingStatusID = 2 -- performed without pricing adjustment, not cancelled and not other changes
                         AND
                        -- at 24 hours, 1 day, after service ended (more than that is fine)
                        getdate() >= dateadd(hh, 24, E.EndTime)
                        /* AND
                         getdate() < dateadd(hh, 25, E.EndTime)
                        */
                         AND
                        (SELECT count(*)
                         FROM Booking As B2 INNER JOIN BookingRequest As BR2 ON BR2.BookingRequestID = B2.BookingRequestID
                         WHERE
                            BR2.ProviderUserID = BR.ProviderUserID
                             AND
                            B2.BookingStatusID = 4 --Complete bookings
                        ) > 0 -- There are complete bookings (almost 1)
            ";
            var bookings = db.Query(sqlGet);

            foreach (var b in bookings){
                try {
                    // Release the payment
                    var errmsg = LcPayment.ReleaseTransactionFromEscrow(b.PaymentTransactionID);
                    
                    if (errmsg == null) {
                        // Mark as payed (StatusID:4 'complete')
                        db.Execute(@"
                            UPDATE  Booking
                            SET     BookingStatusID = 4
                                    ,UpdatedDate = getdate()
                            WHERE   BookingID = @0", b.BookingID);
                    
                        // Send messages
                    
                        // Notify customer and provider with an updated booking details:
                        LcMessaging.SendBookingUpdate(b.BookingID, 's');
                    
                        // Update MessagingLog for the booking
                        db.Execute(sqlAddBookingMessagingLog, b.BookingID, "[Release Payment 24H]");

                        items++;
                        messages += 2;
                    }
                    else {
                        
                        var errTitle = "Booking Release Payment 24H";
                        var errDesc = String.Format(
                            "BookingID: {0}, TransactionID: {1} Not payed, error on Braintree 'release transaction from escrow': {2}",
                            b.BookingID,
                            b.PaymentTransactionID,
                            errmsg
                        );
                        
                        LcMessaging.NotifyError(errTitle, "/ScheduleTask", errDesc);
                        
                        logger.Log("Error on: " + errTitle + "; " + errDesc);
                    }
                } catch (Exception ex){
                    logger.LogEx("Booking Release Payment 24H", ex);
                }
            }
        }
        logger.Log("Total of Booking Release Payment after 24H: {0}, messages sent: {1}", items, messages);
        totalitems += items;
        totalmessages += messages;
        
        
        // Ending work with database
    }
    
    logger.Log("Elapsed time {0}, for {1} bookings affected and {2} messages sent", DateTime.Now - elapsedTime, totalitems, totalmessages);


    /*
     * iCalendar
     */
    DateTime partialElapsedTime = DateTime.Now;
    
    int successCalendars = 0,
        failedCalendars = 0;
        
    foreach(var err in LcCalendar.BulkImport()){
        if (err == null) {
            successCalendars++;
        } else {
            failedCalendars++;
            logger.LogEx("Import Calendar", err);
        }
    }

    logger.Log("Elapsed time {0}, for {1} user calendars imported, {2} failed", DateTime.Now - partialElapsedTime, successCalendars, failedCalendars);
    

    /*
     * Task Ended
     */
    logger.Log("Total Elapsed time {0}", DateTime.Now - elapsedTime);

    string logresult = logger.ToString();
    // Finishing: save log on disk, per month rotation
    //try {
        logger.Save();
    //}catch { }
}
@if (!LcHelpers.InLive)
{
    //Response.ContentType = "text/plain";
    <div><h2>Log</h2>
    <pre>@logresult</pre>
    </div>

    try
    {
        if (LcCalendar.LastBulkImport != null)
        {
        <div><h2>Timeline</h2>
        @Html.Raw(LcCalendar.LastBulkImport.ToHtmlString(showStartTime: false, showEndTime: false, showNotes: false))
        </div>
        }
    } catch {}
}
