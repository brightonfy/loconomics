@*
    Read and write events, simplified with the data usually used in user interface
    and some extra convenience options.

    NOTE: This is a convenience API, a full API for all the back-end data resides
        under icalendar/events.

    Options:
    GET
        - types[]:array[int] Optional. List of CalendarEventTypeIDs to filter the events returned.
            Possible values are the IDs from records on the table [CalendarEventType].
        - start:datetime Optional. Start date of the range of events included partial or completely
        - end:datetime Optional. End date of the range of events included partial or completely.

    GET /@id
        - @id:int the Event Id to retrieve; must be owned by the current user or 'not found' is returned

    POST
        - EventTypeID:int
        - AvailabilityTypeID:int
        - Summary:string
        - StartTime:datetime
        - EndTime:datetime
        - IsAllDay:bool
        - Location:string
        - Description:string
        - FrequencyTypeID:int
        - Ending:string Possible values allowed: never, date, ocurrences
        - Count:int? For Ending 'ocurrences', number of ocurrences/repetitions of the recurrent event
        - Until:datetime? For Ending 'date', datetime of the latest recurrent ocurrence of the event
        - Interval:int Interval of repetition, 'every each X days/months/etc.',
        - SelectedWeekDays[]:array[int] List of week days for the recurrent rule, when the FrequencyTypeID
            is 'weekly'. Sunday is 0, up to Saturday 6
        - MonthlyWeekDay:bool Express if, for FrequencyTypeID 'monthly', the recurrent day must be the
            day of the month (value false, by default), or the day of the week (value true).

    PUT /@id
        # Same parameters set than POST

    Limitations for edition methods:
    - On edition success, a "GET /@id" result is returned so the generated EventID can be read and any other
        server side edition (UpdateDate field, for example)
    - Events marked with ReadOnly:true will not be modified even if a request is performed, the untouched event
        is returned
    - Events with a read-only EventTypeID will fail to insert/edit/delet.
*@
@functions{
    public class RestEvents : RestWebPage
    {
        public override dynamic Get()
        {           
            // Item ID
            if (UrlData[0].IsInt())
            {
                return GetItem(UrlData[0].AsInt(0));
            }
            
            // Parameters
            int userId = WebSecurity.CurrentUserId;

            // More parameters
            var types = Request.QueryString.GetValues("types[]");
            var typesIDs = new List<int>();
            if (types != null) {
                foreach(var type in types) {
                    typesIDs.Add(type.AsInt(0));
                }
            } else {
                // By default, show events for the common displayed types
                // (it avoids the internal type 'work hours')
                typesIDs.AddRange(new int[]{1, 3, 4, 5, 6});
            }

            var start = DateTimeFromISO(Request.QueryString["start"]);
            var end = DateTimeFromISO(Request.QueryString["end"]);

            // Data
            var list = LcCalendar.GetSimplifiedEvents(userId, typesIDs.ToArray<int>(), start, end);

            return list;
        }
        
        public dynamic GetItem(int eventID)
        {
            // Parameters
            int userID = WebSecurity.CurrentUserId;

            if (eventID > 0)
            {
                var item = (IEnumerable<dynamic>)LcCalendar.GetSimplifiedEvents(userID, null, null, null, eventID);
                if (item != null && item.Count() > 0)
                {
                    return item.First();
                }
            }

            throw new HttpException(404, "Event not found.");
        }
        
        public dynamic DelItem(int eventID)
        {
            // Parameters
            int userID = WebSecurity.CurrentUserId;

            try {
                var item = LcCalendar.DelSimplifiedEvent(userID, eventID);
                if (item != null) {
                    return item;
                }

                throw new HttpException(404, "Event not found.");
            }
            catch (ConstraintException delEx)
            {
                // The event cannot be deleted:
                throw new HttpException(400, delEx.Message);
            }
        }
        
        public dynamic SetItem(int eventID)
        {
            // Parameters
            int userID = WebSecurity.CurrentUserId;
            
            Validation.RequireField("Summary", LcRessources.RequiredField("Summary"));
            Validation.RequireField("StartTime", LcRessources.RequiredField("Start Date"));
            Validation.RequireField("EndTime", LcRessources.RequiredField("End Date"));
            Validation.Add("StartTime", Validator.DateTime("Start date/time is not valid"));
            Validation.Add("EndDate", Validator.DateTime("End date/time is not valid"));
            Validation.Add("Interval", Validator.Integer("'Repeat every' must be a number"));
            Validation.Add("Count", Validator.Integer("Number of occurrences must be a number"));
            Validation.Add("Until", Validator.DateTime("Repetition End Date is not valid"));
            
            if (!Validation.IsValid()) {
                throw new HttpException(404, LcRessources.ValidationSummaryTitle);
            }
            
            LcCalendar.SimplifiedRecurrenceRule rrule = null;
            int repeatFrequency = Request["FrequencyTypeID"].AsInt(0);
            List<int> selectedWeekDays = new List<int>();
            if (Request.Form.AllKeys.Contains<string>("SelectedWeekDays[]")) {
                foreach(var w in Request.Form.GetValues("SelectedWeekDays[]")){
                    // Try-catch because a bad-request can send non-valid values or repeated
                    // ones, making the list-addition fail. For normal use, that problem
                    // never will happen, because of that a better control 
                    // without try-catch is over-complicate the code
                    try{
                        selectedWeekDays.Add(w.AsInt());
                    }catch{}
                }
            }
            
            if (repeatFrequency > 0) {
                rrule = new LcCalendar.SimplifiedRecurrenceRule {
                    FrequencyTypeID = repeatFrequency,
                    Ending = Request["Ending"],
                    Count = Request["Ending"] == "ocurrences" ? (int?)Request["Count"].AsInt() : null,
                    Until = Request["Ending"] == "date" ? (DateTime?)Request["Until"].AsDateTime() : null,
                    Interval = Request["Interval"].AsInt(1),
                    SelectedWeekDays = selectedWeekDays,
                    MonthlyWeekDay = Request["MonthlyWeekDay"].AsBool()
                };
            }
            else {
                rrule = null;
            }

            LcCalendar.SetSimplifiedEvent(userID, eventID,
                Request["EventTypeID"].AsInt(),
                Request["AvailabilityTypeID"].AsInt(),
                Request["Summary"],
                Request["StartTime"].AsDateTime(),
                Request["EndTime"].AsDateTime(),
                Request["IsAllDay"].AsBool(),
                Request["Location"],
                Request["Description"],
                rrule    
            );
            
            // Return database copy
            return GetItem(eventID);
        }

        public override dynamic Post()
        {
            if (UrlData.Count > 0)
                throw new HttpException(405, "Method not allowed.");

            return SetItem(0);
        }

        public override dynamic Put()
        {           
            dynamic updated = null;
            if (UrlData.Count == 1)
                updated = SetItem(UrlData[0].AsInt(0));

            if (updated == null) {
                if (UrlData.Count == 0)
                    throw new HttpException(405, "Method not allowed.");
                else
                    throw new HttpException(404, "Event not found.");
            }

            return updated;
        }

        public override dynamic Delete()
        {
            dynamic deleted = null;
            if (UrlData.Count == 1)
                deleted = DelItem(UrlData[0].AsInt(0));

            if (deleted == null) {
                if (UrlData.Count == 0)
                    throw new HttpException(405, "Method not allowed.");
                else
                    throw new HttpException(404, "Event not found.");
            }
          
            return deleted;
        }
    }
}
@{
    Response.RestRequiresUser(LcData.UserInfo.UserType.User);
    new RestEvents().JsonResponse(this);
}
