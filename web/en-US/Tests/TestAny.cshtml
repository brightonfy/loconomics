@* Placeholder testing area
 *@
@{
    LcHelpers.TestArea();
    Layout = "_TestLayout.cshtml";

    DateTime start = DateTime.Now;

    //var data = LcEmailTemplate.GetBookingInfo(); // LcRest.Booking.GetList(141, DateTime.Today.AddDays(-200), DateTime.Today);
    
    var cu = new CalendarDll.CalendarUtils();
    var calUser = new CalendarDll.CalendarUser(141);
    var startTime = new DateTime(2015, 10, 12); //new DateTime(2012, 1, 1); 
    var endTime = new DateTime(2015, 10, 19);
    
    //var aux = cu.OptimizedGetEventsByUserDateRange(calUser, startTime, endTime, "");
    //var data = aux.Select(ev => new { startTime = ev.Start.ToString("s"), endTime = ev.End.ToString("s"), uid = ev.UID, dow = ev.Start.DayOfWeek.ToString(), sum = ev.Summary });

    //var data = cu.GetFreeEvents(calUser, startTime, endTime, DateTime.Today);
}
@*ObjectInfo.Print(data)

PROCESS DURATION: @((DateTime.Now - start).ToString())
*@
@functions {
    Dictionary<int, int> AvailabilityPriorities = new Dictionary<int, int> {
        { (int)LcCalendar.AvailabilityType.Busy, 40 }, // Busy stronger
        { (int)LcCalendar.AvailabilityType.Unavailable, 30 }, // Unavailable
        { (int)LcCalendar.AvailabilityType.Tentative, 20 }, // Tentative
        { (int)LcCalendar.AvailabilityType.Free, 10 }  // Free
    };
    CalendarDll.CalendarUtils.DateRange GetPriorityDateRange(CalendarDll.CalendarUtils.DateRange date1, CalendarDll.CalendarUtils.DateRange date2) {
        var pri1 = AvailabilityPriorities[date1.AvailabilityTypeID];
        var pri2 = AvailabilityPriorities[date2.AvailabilityTypeID];
        return pri1 >= pri2 ? date1 : date2;
    }
    DateTime MinDateTime(DateTime t1, DateTime t2)
    {
        return t1 <= t2 ? t1 : t2;
    }
    DateTime MaxDateTime(DateTime t1, DateTime t2)
    {
        return t1 >= t2 ? t1 : t2;
    }
    IEnumerable<CalendarDll.CalendarUtils.DateRange> GetTimeline(IEnumerable<CalendarDll.CalendarUtils.DateRange> dateRanges)
    {
        var enumerate = dateRanges.GetEnumerator();
        // Quick return
        if (!enumerate.MoveNext()) {
            yield break;
        }
        // First one, as previous on the iteration.
        var prevsBuffer = new List<CalendarDll.CalendarUtils.DateRange>();
        prevsBuffer.Add(enumerate.Current);
        var newsBuffer = new List<CalendarDll.CalendarUtils.DateRange>();
        // On each iteration, number of queued items in the buffer that can be released
        var dequeueCount = 0;
        // On each iteration, number of queued items in the buffer After the dequeueCount
        // that must be discarded/removed frmo the buffer without return them, because
        // gets obsolete after perform the analysis (that means that new, fragmented,
        // ranges were created for that one because of collisions)
        var discardCount = 0;
        // On each iteration, current element must or must not be added 'as is' to the queue
        var addCurrentToBuffer = true;

        // Implemented several passes when an analyzed lists of 'prevsBuffer' contains more than 1
        // element, because how elements may overlap has edge cases that only can be solved
        // by reordering the list and apply the logic on it.
        //
        // NOTE: It's something optmized because rather than re-analyze the whole resultsets when
        // a complete pass is done [like GetTimeline(GetTimeline(...))], only the specific sections of overlaped ranges
        // performs a second (or more) passes, and still is effective.
        // 
        // TODO: Investigate if is possible a logic that avoid multiple passes OR a most effective way to check when
        // multiple passes are needed (right now just [prevsBuffer.length > 1], maybe other quick logic can discard
        // cases that match that condiction but don't need a second pass).
        var needsAnotherPass = false;

        while (enumerate.MoveNext())
        {
            var current = enumerate.Current;
            needsAnotherPass = prevsBuffer.Count > 1;
            
            foreach (var prev in prevsBuffer) {
                if (current.StartTime >= prev.EndTime)
                {
                    // Previous can be dequeue (will not collide with following ranges)
                    dequeueCount++;
                }
                else /* current.StartTime < prev.EndTime */
                {
                    addCurrentToBuffer = false;
                    discardCount++;
                    // Intersection of events:
                    // |.....prev.....|
                    //         |.....current.....|
                    // |.prev..|.new..|..current.|
                    //
                    // TODO: Optimize creation of ranges: only 2 are needed, because the
                    // new range will share its availability with one of the others, allowing
                    // to mix both in one.
                    //
                    // IMPORTANT: current may finish before prev (current inside prev) like
                    // |.............prev..............|
                    //        |......current....|
                    // |.prev.|.prev-or-current.|.prev.|
                    //
                    // TODO: If prev has higher or same priority, there is only one range, the prev
                    // TODO: If current has higher priority, three ranges are needed, the current keeps 'as is'
                    //
                    // IMPORTANT: because of multiple ranges overlapping and ones first being longer than following ones,
                    // the split behavior may end creating 'prev' ranges that happens AFTER 'current', because
                    // of that the first cut may end being a prev or current section and 'minDateTime and maxdatetime' are required.
                    // The graph can be something like
                    //        |.......prev........|
                    // |....current....|
                    // |p-or-c|.p-or-c.|.prev.....|
                    // ANOTHER EDGE CASE Because multiple overlapping and passes
                    //                  |.....prev.....|
                    // |...current..|
                    // |...current..|new|.....prev.....|
                    
                    // - Return a reduced version of the prev
                    // (if there is place for one!)
                    if (prev.StartTime != current.StartTime) {
                        var minStart = MinDateTime(prev.StartTime, current.StartTime);
                        newsBuffer.Add(new CalendarDll.CalendarUtils.DateRange
                        {
                            StartTime = minStart,
                            EndTime = MaxDateTime(prev.StartTime, current.StartTime),
                            AvailabilityTypeID = minStart == current.StartTime ? current.AvailabilityTypeID : prev.AvailabilityTypeID
                        });
                    }
                    // - New range on the intersection, with the stronger availability
                    newsBuffer.Add(new CalendarDll.CalendarUtils.DateRange
                    {
                        StartTime = current.StartTime,
                        EndTime = MinDateTime(current.EndTime, prev.EndTime),
                        AvailabilityTypeID = GetPriorityDateRange(prev, current).AvailabilityTypeID
                    });
                    // - Reduced version of the current
                    // (if there is place for one!)
                    if (prev.EndTime != current.EndTime) {
                        var maxEnd = MaxDateTime(prev.EndTime, current.EndTime);
                        newsBuffer.Add(new CalendarDll.CalendarUtils.DateRange
                        {
                            StartTime = MinDateTime(prev.EndTime, current.EndTime),
                            EndTime = maxEnd,
                            AvailabilityTypeID = maxEnd == current.EndTime ? current.AvailabilityTypeID : prev.AvailabilityTypeID
                        });
                    }
                }
            }
            
            if (addCurrentToBuffer) {
                // Current must be in the list
                prevsBuffer.Add(current);
            }
            addCurrentToBuffer = true;
            
            // Add the new ones to queue
            foreach (var ne in newsBuffer)
                prevsBuffer.Add(ne);
            newsBuffer.Clear();

            // Check two latest ranges in order to fill in a hole (if any)
            if (prevsBuffer.Count > 1) {
                var preHole = prevsBuffer[prevsBuffer.Count - 2];
                var postHole = prevsBuffer[prevsBuffer.Count - 1];
                if (postHole.StartTime > preHole.EndTime)
                {
                    // There is a gap:
                    // fill it with unavailable slot
                    var hole = new CalendarDll.CalendarUtils.DateRange
                    {
                        AvailabilityTypeID = (int)LcCalendar.AvailabilityType.Unavailable,
                        StartTime = preHole.EndTime,
                        EndTime = postHole.StartTime
                    };
                    // Must be inserted in the place of postHole (to keep them sorted), and re-add that after
                    prevsBuffer[prevsBuffer.Count - 1] = hole;
                    prevsBuffer.Add(postHole);
                    dequeueCount++;
                }
            }

            // Dequee: return and remove from buffer that elements that are ready
            for (var i = 0; i < dequeueCount; i++) {
                // Since we are modifing the buffer on each iteration,
                // the element to return and remove is ever the first (0)
                yield return prevsBuffer[0];
                prevsBuffer.RemoveAt(0);
            }
            dequeueCount = 0;
            // Discard: remove from buffer, but NOT return, elements that get obsolete
            for (var i = 0; i < discardCount; i++)
            {
                // Since we are modifing the buffer on each iteration,
                // the element to remove is ever the first (0)
                prevsBuffer.RemoveAt(0);
            }
            discardCount = 0;
            
            // Multi passes are needed to ensure correct results.
            if (needsAnotherPass) {
                prevsBuffer = GetTimeline(prevsBuffer.OrderBy(x => x.StartTime)).ToList();
            }
        }

        // Return last pending:
        foreach (var range in prevsBuffer)
            yield return range;
    }
    
    List<string> CheckTestTimeline(string name, IEnumerable<CalendarDll.CalendarUtils.DateRange> result, IList<CalendarDll.CalendarUtils.DateRange> expected) {
        var testErrors = new List<string>();
        if (result.Count() != expected.Count)
        {
            testErrors.Add(name + ": expected result set has different size");
        }
        else
        {
            var ir = -1;
            foreach (var r in result)
            {
                ir++;
                if (!r.Equals(expected[ir]))
                {
                    testErrors.Add(name + ": result " + ir + " is different");
                }
            }
        }
        return testErrors;
    }
    
    /// <summary>
    /// Unit Tests on CheckTimeline
    /// Returns a list of errors
    /// </summary>
    /// <returns></returns>
    List<string> CheckTimeline_UnitTests() {
        var testdataBasic = new List<CalendarDll.CalendarUtils.DateRange>
        {
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 3, 5, 0, 0),
                EndTime = new DateTime(2015, 10, 3, 8, 0, 0),
                AvailabilityTypeID = 2
            },
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 3, 8, 0, 0),
                EndTime = new DateTime(2015, 10, 3, 10, 0, 0),
                AvailabilityTypeID = 1
            },
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 3, 12, 0, 0),
                EndTime = new DateTime(2015, 10, 3, 14, 0, 0),
                AvailabilityTypeID = 1
            },
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 3, 12, 0, 0),
                EndTime = new DateTime(2015, 10, 3, 14, 0, 0),
                AvailabilityTypeID = 3
            },
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 3, 13, 0, 0),
                EndTime = new DateTime(2015, 10, 3, 15, 0, 0),
                AvailabilityTypeID = 2
            },
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 3, 15, 0, 0),
                EndTime = new DateTime(2015, 10, 3, 18, 0, 0),
                AvailabilityTypeID = 1
            },
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 3, 16, 0, 0),
                EndTime = new DateTime(2015, 10, 3, 17, 0, 0),
                AvailabilityTypeID = 2
            }
        };
        var testresultBasic = new List<CalendarDll.CalendarUtils.DateRange>
        {
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 3, 5, 0, 0),
                EndTime = new DateTime(2015, 10, 3, 8, 0, 0),
                AvailabilityTypeID = 2
            },
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 3, 8, 0, 0),
                EndTime = new DateTime(2015, 10, 3, 10, 0, 0),
                AvailabilityTypeID = 1
            },
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 3, 10, 0, 0),
                EndTime = new DateTime(2015, 10, 3, 12, 0, 0),
                AvailabilityTypeID = 0
            },
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 3, 12, 0, 0),
                EndTime = new DateTime(2015, 10, 3, 13, 0, 0),
                AvailabilityTypeID = 3
            },
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 3, 13, 0, 0),
                EndTime = new DateTime(2015, 10, 3, 14, 0, 0),
                AvailabilityTypeID = 2
            },
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 3, 14, 0, 0),
                EndTime = new DateTime(2015, 10, 3, 15, 0, 0),
                AvailabilityTypeID = 2
            },
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 3, 15, 0, 0),
                EndTime = new DateTime(2015, 10, 3, 16, 0, 0),
                AvailabilityTypeID = 1
            },
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 3, 16, 0, 0),
                EndTime = new DateTime(2015, 10, 3, 17, 0, 0),
                AvailabilityTypeID = 2
            },
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 3, 17, 0, 0),
                EndTime = new DateTime(2015, 10, 3, 18, 0, 0),
                AvailabilityTypeID = 1
            }      
        };
        var testdata3Coincidences = new List<CalendarDll.CalendarUtils.DateRange>
        {
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 3, 16, 0, 0),
                EndTime = new DateTime(2015, 10, 3, 20, 0, 0),
                AvailabilityTypeID = 1
            },
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 3, 17, 0, 0),
                EndTime = new DateTime(2015, 10, 3, 18, 0, 0),
                AvailabilityTypeID = 2
            },
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 3, 17, 30, 0),
                EndTime = new DateTime(2015, 10, 3, 21, 0, 0),
                AvailabilityTypeID = 3
            },
       
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 4, 0, 0, 0),
                EndTime = new DateTime(2015, 10, 4, 10, 0, 0),
                AvailabilityTypeID = 1
            },
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 4, 2, 0, 0),
                EndTime = new DateTime(2015, 10, 4, 6, 0, 0),
                AvailabilityTypeID = 2
            },
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 4, 5, 0, 0),
                EndTime = new DateTime(2015, 10, 4, 8, 0, 0),
                AvailabilityTypeID = 3
            },
        };
        var testresult3Coincidences = new List<CalendarDll.CalendarUtils.DateRange>
        {
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 3, 16, 0, 0),
                EndTime = new DateTime(2015, 10, 3, 17, 0, 0),
                AvailabilityTypeID = 1
            },
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 3, 17, 0, 0),
                EndTime = new DateTime(2015, 10, 3, 17, 30, 0),
                AvailabilityTypeID = 2
            },
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 3, 17, 30, 0),
                EndTime = new DateTime(2015, 10, 3, 18, 0, 0),
                AvailabilityTypeID = 2
            },
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 3, 18, 0, 0),
                EndTime = new DateTime(2015, 10, 3, 20, 0, 0),
                AvailabilityTypeID = 3
            },
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 3, 20, 0, 0),
                EndTime = new DateTime(2015, 10, 3, 21, 0, 0),
                AvailabilityTypeID = 3
            },

            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 3, 21, 0, 0),
                EndTime = new DateTime(2015, 10, 4, 0, 0, 0),
                AvailabilityTypeID = 0
            },
       
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 4, 0, 0, 0),
                EndTime = new DateTime(2015, 10, 4, 2, 0, 0),
                AvailabilityTypeID = 1
            },
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 4, 2, 0, 0),
                EndTime = new DateTime(2015, 10, 4, 5, 0, 0),
                AvailabilityTypeID = 2
            },
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 4, 5, 0, 0),
                EndTime = new DateTime(2015, 10, 4, 6, 0, 0),
                AvailabilityTypeID = 2
            },
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 4, 6, 0, 0),
                EndTime = new DateTime(2015, 10, 4, 8, 0, 0),
                AvailabilityTypeID = 3
            },
            new CalendarDll.CalendarUtils.DateRange {
                StartTime = new DateTime(2015, 10, 4, 8, 0, 0),
                EndTime = new DateTime(2015, 10, 4, 10, 0, 0),
                AvailabilityTypeID = 1
            },
        };

        var data2 = GetTimeline(testdataBasic);

        var testErrors = CheckTestTimeline("Basic", data2, testresultBasic);

        var data2b = GetTimeline(testdata3Coincidences);
        testErrors.AddRange(CheckTestTimeline("3Coincidences", data2b, testresult3Coincidences));

        return testErrors;
    }
}
@{
   start = DateTime.Now;
   //var occurrences = cu.GetUtcFreeOccurrences(calUser.Id, startTime, endTime);
   //var data2 = GetTimeline(occurrences);

   var testErrors = CheckTimeline_UnitTests();
}
@ObjectInfo.Print(testErrors)
@*ObjectInfo.Print(data2)*@
@*ObjectInfo.Print(data2b)*@

PROCESS DURATION: @((DateTime.Now - start).ToString())

@{return;
    start = DateTime.Now;
    var data3 = LcCalendar.GetAvailability.Weekly(calUser.Id, startTime, endTime, false);
}
@ObjectInfo.Print(data3)

PROCESS DURATION: @((DateTime.Now - start).ToString())

@*{
    var ical = new DDay.iCal.iCalendar();
    var ievent = new DDay.iCal.Event();
    ievent.Start = new DDay.iCal.iCalDateTime(2015, 10, 12, 10, 0, 0, "");
    ievent.End = new DDay.iCal.iCalDateTime(2015, 10, 12, 15, 0, 0, "");
    ievent.Status = DDay.iCal.EventStatus.Confirmed;
    ievent.UID = "1234";
    var rrule = new DDay.iCal.RecurrencePattern();
    rrule.ByDay.Add(new DDay.iCal.WeekDay(DayOfWeek.Monday));
    rrule.FirstDayOfWeek = 0;
    rrule.Interval = 1;
    rrule.Frequency = DDay.iCal.FrequencyType.Weekly;
    ievent.RecurrenceRules.Add(rrule);
    ical.Events.Add(ievent);

    var userEvents = cu.GetEventsByUserDateRange(calUser, new DateTime(2006, 1, 1), new DateTime(2006, 1, 1), "");
    var userEvent = userEvents.First();

    //ical.Events.Add(userEvent);

    var data4 = userEvent.GetOccurrences(new DDay.iCal.iCalDateTime(2015, 10, 12, 10, 0, 0, ""), new DDay.iCal.iCalDateTime(2015, 11, 12, 15, 0, 0, ""))
    .Select(occ => {
        return new
        {
            start = occ.Period.StartTime.ToString(),
            end = occ.Period.EndTime.ToString(),
            uid = ((DDay.iCal.IEvent)occ.Period.StartTime.AssociatedObject).UID,
            status = ((DDay.iCal.IEvent)occ.Period.StartTime.AssociatedObject).Status
        };
    });
}
@ObjectInfo.Print(data4)
@ObjectInfo.Print(new {
    start = userEvent.Start.ToString(),
    end = userEvent.End.ToString(),
    status = userEvent.Status,
    uid = userEvent.UID,
    rrule = userEvent.RecurrenceRules
})*@