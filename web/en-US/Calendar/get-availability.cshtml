@*
    This page retrieves the user availability for the date range as JSON.

    INPUT:
        user
        start / date
        end
        type
*@
@{
    // Prepare result struct
    var result = new Dictionary<string, object>();
    int resultCode = -1;
    // To represent date and times in the returned JSON we 
    // use the ISO-8601 long formats (long format has separators versus
    // short version without separators),
    // and precision to seconds.
    var dateFormat = "yyyy'-'MM'-'dd";
    var timeFormat = @"hh\:mm\:ss";
    var systemCulture = System.Globalization.CultureInfo.InvariantCulture;

    try{
        // Defaults
        var userId = WebSecurity.IsAuthenticated ? WebSecurity.CurrentUserId : 0;
        var type = Request["type"] ?? "weekly";

        // Input data
        userId = Request["user"].AsInt(userId);

        // Get data
        if (type == "workHours") {
            var data = LcCalendar.GetProviderWorkHours(userId);
            
            // Create result
            var slots = new Dictionary<string, List<string>>();
            
            // We set 'unavailable' (any database status except free -includes: unavailable, busy, tentative, offline)
            // as the default state, then we only return 'available' (free on database) slots
            result["defaultStatus"] = "unavailable";
            result["status"] = "available";
            
            foreach(var r in data) {
                var wk = String.Format(systemCulture, "{0}", r.DayOfWeek).ToLower();
                if (!slots.ContainsKey(wk)) {
                    slots.Add(wk, new List<string>());
                }

                var forslot = r.StartTime;
                // Its less than EndTime, because EndTime is an inclusive time-range and we
                // return only the start of each time-slot.
                while (forslot < r.EndTime) {
                    slots[wk].Add(forslot.ToString(timeFormat));
                    // Next slot
                    forslot = forslot.Add(TimeSpan.FromMinutes(15));
                }
            }
            
            result["slots"] = slots;
            
        } else if (type == "monthly") {
            var dates = getMonthlyDatesRequested();
            
            var data = LcCalendar.GetUserAvailability(userId, dates.Start, dates.End);

            // Create result
            result["defaultStatus"] = "unavailable";
            if (Request["editable"].AsBool()) {
                result["slots"] = getEditableMonthlySlots(dates.Start, dates.End, dateFormat, data);
            } else {
                result["slots"] = getReadOnlyMonthlySlots(dates.Start, dates.End, dateFormat, data);
            }
            
        } else if (type == "monthly-schedule") {
            var dates = getMonthlyDatesRequested();
            
            var data = LcCalendar.GetMonthlyScheduleEvents(userId, dates);

            // Create result
            result["defaultStatus"] = "available";
            result["slots"] = getMonthlyScheduleSlots(dates, dateFormat, data);
            
            // TODO: Recurrent events (since recurrent bookings are not used still and its more complex
            // do that computation -and time consuming- currently either GetBookingEvents nor fillBookingEvents
            // are being aware of the possibility to have recurrent rules with occurrences happening on our
            // dates-range)
            fillBookingEvents(LcCalendar.GetBookingEvents(userId, dates), result, dateFormat, timeFormat);
            
        } else { // "weekly"
            // Input data
            var defStart = LcHelpers.GetFirstWeekDay(DateTime.Today);
            var defEnd = LcHelpers.GetLastWeekDay(DateTime.Today);
            var startDate = Request["start"].AsDateTime(defStart);
            var endDate = Request["end"].AsDateTime(defEnd).AddDays(1).AddSeconds(-1);
            
            var data = LcCalendar.GetUserAvailability(userId, startDate, endDate);

            // Create result
            var slots = new Dictionary<string, List<string>>();
            // We prepare the slots with every date in the range, no matter
            // if some dates ends up without data (empty value list) we need to be
            // explicit about the returned dates.
            var fordate = startDate;
            while (fordate <= endDate) {
                slots.Add(fordate.ToString(dateFormat), new List<string>());
                // Next date
                fordate = fordate.AddDays(1);
            }
        
            // We set 'unavailable' (any database status except free -includes: unavailable, busy, tentative, offline)
            // as the default state, then we only return 'available' (free on database) slots
            result["defaultStatus"] = "unavailable";
            result["status"] = "available";
            foreach(var ev in data) {
            
                if (ev.CalendarAvailabilityTypeID == (int)LcCalendar.AvailabilityType.Free) {
                    // Result set is organized per dates,
                    var date = ev.DateSet.ToString(dateFormat);
                    // and inside, per time slot.
                    var slot = ev.TimeBlock.ToString(timeFormat);
                    // Added to the list
                    slots[date].Add(slot);
                }
            }

            result["slots"] = slots;
       }
        
        //throw new Exception("Inside Test error");
        
        // Success
        resultCode = 0;

    } catch(Exception ex){
        result["ErrorMessage"] = ex.Message;
    }

    // Output data
    LcHelpers.ReturnJsonResult(resultCode, result);
}
@functions {

    DatesRange getMonthlyDatesRequested() {
        var startDate = Request["start"].AsDateTime(DateTime.MinValue);
        var endDate = Request["end"].AsDateTime(DateTime.MinValue);
            
        if (startDate == DateTime.MinValue) {
            var refDate = (Request["date"]).AsDateTime(DateTime.Today);
            // This gets the firts week-date for the first month-date for the refDate:
            startDate = LcHelpers.GetFirstWeekDay(refDate.AddDays(0 - refDate.Day + 1));
            // Last week-date for the last month-date for the refDate
            endDate = LcHelpers.GetLastWeekDay(refDate.AddMonths(1).AddDays(-1));
        }
        
        return new DatesRange(startDate, endDate);
    }
    
    Dictionary<string, string> getReadOnlyMonthlySlots(DateTime startDate, DateTime endDate, string dateFormat, dynamic data) {
        var slots = new Dictionary<string, string>();
        // We prepare the slots with every date in the range, no matter
        // if some dates ends up without data (empty value list) we need to be
        // explicit about the returned dates.
        var fordate = startDate;
        while (fordate <= endDate) {
            slots.Add(fordate.ToString(dateFormat), "");
            // Next date
            fordate = fordate.AddDays(1);
        }
        
        // We set 'unavailable' (any database status except free -includes: unavailable, busy, tentative, offline)
        // or 'available' (free on database)
        // ALMOST one slot free sets the date availability as 'available' (because most times there will be
        // unavailable slots, and that cannot set all the date as unavailable)
        var curDate = startDate;
        var curStatus = "unavailable";
        bool jump = false;
        foreach(var ev in data) {
            if (jump || curDate != ev.DateSet) {
                jump = false;
                var strdate = curDate.ToString(dateFormat);
                slots[strdate] = curStatus;
                curDate = ev.DateSet;
                curStatus = "unavailable";
            }
            if (ev.CalendarAvailabilityTypeID == (int)LcCalendar.AvailabilityType.Free) {
                curStatus = "available";
                jump = true;
            }
        }
        var laststrdate = curDate.ToString(dateFormat);
        slots[laststrdate] = curStatus;
        
        return slots;
    }
    
    Dictionary<string, Dictionary<string, string>> getEditableMonthlySlots(DateTime startDate, DateTime endDate, string dateFormat, dynamic data) {
        var slots = new Dictionary<string, Dictionary<string, string>>();
        // We prepare the slots with every date in the range, no matter
        // if some dates ends up without data (empty value list) we need to be
        // explicit about the returned dates.
        var fordate = startDate;
        while (fordate <= endDate) {
            slots.Add(fordate.ToString(dateFormat), new Dictionary<string, string>());
            // Next date
            fordate = fordate.AddDays(1);
        }
        
        // We set 'unavailable' (any database status except free -includes: unavailable, busy, tentative, offline)
        // or 'available' (free on database)
        // ALMOST one slot free sets the date availability as 'available' (because most times there will be
        // unavailable slots, and that cannot set all the date as unavailable)
        var curDate = startDate;
        var curStatus = "unavailable";
        string curStatusSource = null;
        bool jump = false;
        foreach(var ev in data) {
            if (jump || curDate != ev.DateSet) {
                jump = false;
                var strdate = curDate.ToString(dateFormat);
                slots[strdate]["status"] = curStatus;
                slots[strdate]["source"] = curStatusSource ?? "computed";
                curDate = ev.DateSet;
                curStatus = "unavailable";
                curStatusSource = null;
            }
            if (ev.CalendarAvailabilityTypeID == (int)LcCalendar.AvailabilityType.Free) {
                curStatus = "available";
                curStatusSource = "computed";
                jump = true;
            }
        }
        var laststrdate = curDate.ToString(dateFormat);
        slots[laststrdate]["status"] = curStatus;
        slots[laststrdate]["source"] = curStatusSource;
        
        return slots;
    }
    
    Dictionary<string, Dictionary<string, dynamic>> getMonthlyScheduleSlots(DatesRange dates, string dateFormat, dynamic data) {
        var slots = new Dictionary<string, Dictionary<string, dynamic>>();
        // We prepare the slots with every date in the range, no matter
        // if some dates ends up without data (empty value list) we need to be
        // explicit about the returned dates.
        var fordate = dates.Start;
        while (fordate <= dates.End) {
            slots.Add(fordate.ToString(dateFormat), new Dictionary<string, dynamic>());
            // Next date
            fordate = fordate.AddDays(1);
        }
        
        foreach(var ev in data) {
            var strdate = ev.StartTime.ToString(dateFormat);
            // We denote the source of the given data slot is a single record on database ("db")
            // On a user change, it will change to "user" to denote that must be saved.
            slots[strdate]["source"] = "db";
            if (ev.CalendarAvailabilityTypeID == (int)LcCalendar.AvailabilityType.Free) {
                slots[strdate]["status"] = "available";
            } else {
                // On any other status, we set 'unavailable'.
                // Sure we must only have monthly-schedule events with 'unavailable' status for this
                // and 'free' for 'available' slots.
                slots[strdate]["status"] = "unavailable";
            }
        }
        
        return slots;
    }
    
    void fillBookingEvents(dynamic bookingEvents, Dictionary<string, dynamic> result, string dateFormat, string timeFormat) {
        var rEvents = new Dictionary<string, dynamic>();
        var date = DateTime.MinValue;
        
        foreach(var e in bookingEvents) {
            // Format the required events information in the result,
            // indexed by its ID
            rEvents[e.Id.ToString()] = new {
                summary = e.Summary,
                start = e.StartTime.ToString(dateFormat) + "T" + e.StartTime.TimeOfDay.ToString(timeFormat),
                end = e.EndTime.ToString(dateFormat) + "T" + e.EndTime.TimeOfDay.ToString(timeFormat),
                id = e.Id,
                url = LcUrl.LangPath + "dashboard/messages/booking/" + e.BookingID.ToString() + "/"
            };
            
            // Check what dates the booking performs and index it per date-slot:
            // Iterate all days, using the date without time and excluding the EndTime:
            // this avoid include midnight EndTimes while still adding it for other cases
            // (since our iteration 'date' has no time portion and EndTime has it)
            date = e.StartTime.Date;
            while (date < e.EndTime) {
                // Only for existant dates slots
                var strdate = date.ToString(dateFormat);
                if (result["slots"][strdate] != null) {
                    // Check or create if the index of related events exist for the slot
                    if (!result["slots"][strdate].ContainsKey("eventsIds")) {
                        result["slots"][strdate]["eventsIds"] = new List<string>();
                    }
                    // Add the event id to the list:
                    result["slots"][strdate]["eventsIds"].Add(e.Id.ToString());
                }
                
                // Next date
                date = date.AddDays(1);
            }
        }
        result["events"] = rEvents;
    }
}