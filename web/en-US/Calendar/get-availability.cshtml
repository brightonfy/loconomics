@*
    This page retrieves the user availability for the date range as JSON.

    INPUT:
        user
        start
        end
        type
*@
@{
    // Prepare result struct
    var result = new Dictionary<string, object>();
    int resultCode = -1;
    // To represent date and times in the returned JSON we 
    // use the ISO-8601 long formats (long format has separators versus
    // short version without separators),
    // and precision to seconds.
    var dateFormat = "yyyy'-'MM'-'dd";
    var timeFormat = @"hh\:mm\:ss";
    var systemCulture = System.Globalization.CultureInfo.InvariantCulture;

    try{
        // Defaults
        var userId = WebSecurity.IsAuthenticated ? WebSecurity.CurrentUserId : 0;
        var type = Request["type"] ?? "weekly";
        var defStart = LcHelpers.GetFirstWeekDay(DateTime.Today);
        var defEnd = LcHelpers.GetLastWeekDay(DateTime.Today);

        // Input data
        userId = Request["user"].AsInt(userId);
        var startDate = Request["start"].AsDateTime(defStart);
        var endDate = Request["end"].AsDateTime(defEnd);

        // Get data
        if (type == "workHours") {
            var data = LcCalendar.GetProviderWorkHours(userId);
            
            // Create result
            var slots = new Dictionary<string, List<string>>();
            
            // We set 'unavailable' (any database status except free -includes: unavailable, busy, tentative, offline)
            // as the default state, then we only return 'available' (free on database) slots
            result["defaultStatus"] = "unavailable";
            result["status"] = "available";
            
            foreach(var r in data) {
                var wk = String.Format(systemCulture, "{0}", r.DayOfWeek).ToLower();
                if (!slots.ContainsKey(wk)) {
                    slots.Add(wk, new List<string>());
                }

                var forslot = r.StartTime;
                // Its less than EndTime, because EndTime is an inclusive time-range and we
                // return only the start of each time-slot.
                while (forslot < r.EndTime) {
                    slots[wk].Add(forslot.ToString(timeFormat));
                    // Next slot
                    forslot = forslot.Add(TimeSpan.FromMinutes(15));
                }
            }
            
            result["slots"] = slots;
            
        } else if (type == "monthly") {
            
            // Dates are based on the year/month from the given start date
            startDate = new DateTime(startDate.Year, startDate.Month, 1);
            endDate = startDate.AddMonths(1).AddDays(-1);
            
            var data = LcCalendar.GetUserAvailability(userId, startDate, endDate);

            // Create result
            var slots = new Dictionary<string, string>();
            // We prepare the slots with every date in the range, no matter
            // if some dates ends up without data (empty value list) we need to be
            // explicit about the returned dates.
            var fordate = startDate;
            while (fordate <= endDate) {
                slots.Add(fordate.ToString(dateFormat), "");
                // Next date
                fordate = fordate.AddDays(1);
            }
        
            // We set 'unavailable' (any database status except free -includes: unavailable, busy, tentative, offline)
            // or 'available' (free on database)
            // ALMOST one slot free sets the date availability as 'available' (because most times there will be
            // unavailable slots, and that cannot set all the date as unavailable)
            var curDate = startDate;
            var curStatus = "unavailable";
            foreach(var ev in data) {
                if (curDate != ev.DateSet) {
                    var strdate = curDate.ToString(dateFormat);
                    slots[strdate] = curStatus;
                    curDate = ev.DateSet;
                    curStatus = "unavailable";
                }
                if (ev.CalendarAvailabilityTypeID == (int)LcCalendar.AvailabilityType.Free) {
                    curStatus = "available";
                }
            }
            slots[curDate.ToString(dateFormat)] = curStatus;

            result["slots"] = slots;
            
        } else {
            var data = LcCalendar.GetUserAvailability(userId, startDate, endDate);

            // Create result
            var slots = new Dictionary<string, List<string>>();
            // We prepare the slots with every date in the range, no matter
            // if some dates ends up without data (empty value list) we need to be
            // explicit about the returned dates.
            var fordate = startDate;
            while (fordate <= endDate) {
                slots.Add(fordate.ToString(dateFormat), new List<string>());
                // Next date
                fordate = fordate.AddDays(1);
            }
        
            // We set 'unavailable' (any database status except free -includes: unavailable, busy, tentative, offline)
            // as the default state, then we only return 'available' (free on database) slots
            result["defaultStatus"] = "unavailable";
            result["status"] = "available";
            foreach(var ev in data) {
            
                if (ev.CalendarAvailabilityTypeID == (int)LcCalendar.AvailabilityType.Free) {
                    // Result set is organized per dates,
                    var date = ev.DateSet.ToString(dateFormat);
                    // and inside, per time slot.
                    var slot = ev.TimeBlock.ToString(timeFormat);
                    // Added to the list
                    slots[date].Add(slot);
                }
            }

            result["slots"] = slots;
       }
        
        //throw new Exception("Inside Test error");
        
        // Success
        resultCode = 0;

    } catch(Exception ex){
        result["ErrorMessage"] = ex.Message;
    }

    // Output data
    LcHelpers.ReturnJsonResult(resultCode, result);
}