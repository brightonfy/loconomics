@using WebMatrix.Data;
@using WebMatrix.WebData;
@{
    // Set the layout page and page title
    Layout = LcUrl.RenderLangPath + "_SiteLayout.cshtml";
    Page.Title = "Registration Confirmation Page";

    string message = "";
    var confirmationToken = Request["confirmationCode"];
    bool showLogin = false;
    PageData["ShowWelcomePopup"] = false;
    
    // #275: Detecting if the user is logged (maybe autologged) and its account is already confirmed,
    // doing a redirect to dashboard/account/verifications instead of show an error message here
    // (there will be the 'success email verification message')
    var checkUser = LcData.UserInfo.GetUserRow();
    if (checkUser != null) {
        using(var db = Database.Open("sqlloco")) {
            if (db.QueryValue("SELECT UserID FROM webpages_Membership WHERE UserID = @0 AND ConfirmationToken is null",
                checkUser.UserID) == checkUser.UserID) {
                // Account already confirmed, redirect
                Response.Redirect(LcUrl.LangPath + "Dashboard/Account/#account-verifications");
            }
        }
    }

    if (!confirmationToken.IsEmpty()) {
        // IMPORTANT: 2012-07-17, issue #57; We decided use the email-confirmation-code only as a dashboard alert (id:15) instead of blocking the user
        // login, what means user MUST can login but too MUST have an email-confirmation-code; we do that reusing the confirmation code
        // created by asp.net starter-app as until now, but HACKING that system doing a minor change on database, in the 
        // asp.net webpages generated table called 'webpages_Membership': there are two fields to manage confirmation, a bit field (this
        // we will hack changing it to true:1 manually -before of time- on provider create-a-login) and the confirmationToken that we will mantain to allow user confirmation
        // from the welcome-email sent and to off the alert:15, just the next code:
        
        // We need discover what is the UserID for this confirmationToken before confirm, because asp.net WebSecurity API don't tell us nothing:
        using(var db = Database.Open("sqlloco")) {
            var confirmatedUserID = db.QueryValue(@"
                SELECT UserId FROM webpages_Membership
                WHERE ConfirmationToken = @0
            ", confirmationToken);
       
            // The standard WebSecurity.ConfirmAccount code DON'T let use do the auto-login on provider-sign-up without previous confirmation (with an alert for the email
            // confirmation instead a lock login), because of this a hack is done on provider-sign-up login over the IsConfirmed field, and this becomes the ConfirmAccount
            // standard method unuseful (do nothing, really, because it checks IsConfirmed field previuosly and ever is true, doing nothing -we need set to null 
            // ConfirmationToken to off the alert-). On success, ConfirmationToken is set to null and IsConfirmed to 1 (true), supporting both cases, when IsConfirmed is
            // already true and when no.
            //if (WebSecurity.ConfirmAccount(confirmationToken)) {
            if (confirmatedUserID != null) {
                // Set to null ConfirmationToken
                db.Execute("UPDATE webpages_Membership SET ConfirmationToken = null, IsConfirmed = 1 WHERE ConfirmationToken like @0 AND UserID = @1", confirmationToken, confirmatedUserID);
                //message = "Registration Confirmed! Please login to begin.";
                db.Execute("EXEC TestAlertVerifyEmail @0", confirmatedUserID);
                
                
                // IMPORTANT: Since 2012-09-27, issue #134, Auto-login is done on succesful confirmation;
                // some code after next lines (comented as 'starndard logic' will not be executed, and some html, but preserved as documentation)
                // Confirmation sucess, we need user name (email) to auto-login:
                var confirmatedUserEmail = db.QueryValue(@"
                    SELECT TOP 1 email FROM UserProfile WHERE UserID = @0
                ", confirmatedUserID);
                FormsAuthentication.SetAuthCookie(confirmatedUserEmail, false);
                Response.Redirect(LcUrl.LangPath + "Dashboard/Account/#account-verifications");


                // Standard logic (previous 2012-09-27, issue #134):
                message = "Your email was verified successfully! Please login to go to your dashboard:";
                showLogin = true;
            } else {
                message = "Could not verify your registration info";
            }
        }
    }
}
  <div id="container" class="clearfix">

<hgroup class="title">
    @if (showLogin)
    {
        <h1>Your account has been verified</h1>
    }
    else
    {
        <h1>Your account has not yet been verified</h1>
    }
    @if (confirmationToken.IsEmpty())
    {
    <h2>Use the form below to verify your account.</h2>
    }
</hgroup>

@if (!@message.IsEmpty()) {
    <p>@message</p>
    if (showLogin)
    {
        @RenderPage("$Login.cshtml", new { ShowHeader = false, ShowTools = false, Redirect = LcUrl.LangPath + "Dashboard/" })
    }
} else {
    <form method="post" action="">
        <fieldset>
            <legend>Confirmation Code</legend>
            <ol>
                <li>
                    <label for="confirmationCode">Confirmation Code:</label>
                    <input type="text" id="confirmationCode" name="confirmationCode" title="Confirmation code" />
                </li>
            </ol>
            <input type="submit" value="Confirm" title="Confirm registration" />
        </fieldset>
    </form>
}
</div>