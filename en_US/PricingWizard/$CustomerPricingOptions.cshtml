@using WebMatrix.Data;
@{
    var embMode = PageData["EmbeddedMode"] ?? "none"; // possible values: front-end, back-end, calculate, full
    var clienttypeid = PageData["ClientTypeID"] ?? Request["ClientTypeID"].AsInt();
    var pricingtypeid = PageData["PricingTypeID"] ?? Request["PricingTypeID"].AsInt();
    var c = PageData["customerrow"];
    var p = PageData["providerrow"];
    var pos = PageData["positionrow"];
    var idprefix = (PageData["idprefix"] ?? "position" + pos.PositionID.ToString() + "pricingwizard") + "-options";
    decimal timeRequired = 0, optionalServicesTotalPrice = 0;
    dynamic poptions;
    Dictionary<int, decimal> optionalServicesPrices = new Dictionary<int,decimal>();
    // Collection to save time and price for each pricing option item
    // Key will be OptionID, first decimal is time required for the item
    // and second is calculated price for this item
    var pricingOptionsNumbers = new Dictionary<int,decimal[]>();
    
    var tableTitle = PageData["TableTitle"] ?? "Name";
    
    poptions = LcData.GetPricingOptions(c.UserID, p.UserID, pos.PositionID, clienttypeid, pricingtypeid);

    if (IsPost && Validation.IsValid() && embMode != "front-end"){
        // CALCULATING the price for Pricing Options
        foreach (var popt in poptions){
            decimal optPrice = 0;
                
            if (Request[(string)popt.PricingOptionName + "-check"] == "true") {
                string strprice = popt.ProviderDataInputValue.Replace("$", "");
                decimal unitprice = 0;
                decimal.TryParse(strprice, out unitprice);
                decimal quantity = 0;
                switch ((string)popt.CustomerDataInputUnit) {
                    case "number":
                    case "times":
                    case "quantity":
                        quantity = Request[(string)popt.PricingOptionName].AsDecimal();
                        break;
                    case "":
                    default:
                        quantity = 1;
                        break;
                }
                optPrice = Math.Round(quantity * unitprice, 2);
                // Get the equivalent time required from table
                decimal timeVar = 0;
                if (popt.ProviderTimeRequired is decimal) {
                    timeVar = (decimal)popt.ProviderTimeRequired;
                }
                // Add pricing option estimate time to the total time,
                // it's in minutes, we use hours for timeRequired:
                timeRequired += Math.Round(timeVar / 60, 2);
                pricingOptionsNumbers[popt.PricingOptionID] = new decimal[]{timeVar, optPrice};
            }
            optionalServicesPrices.Add(popt.PricingOptionID, optPrice);
            optionalServicesTotalPrice += optPrice;
        }
        // Preparing calculated data to be returned lately
        var calculatedData = new Dictionary<string, object>{
            { "TimeRequired", timeRequired },
            { "OptionalServicesTotalPrice", optionalServicesTotalPrice }
        };
        int dataSaved = -1; // error code for not saved (maybe becaused we are only calculating and is not an error itself)
        
        if (embMode != "calculate") {
            // Save data
            using (var db = Database.Open("sqlloco")){
                /* Save data into pricingwizard tables to remember customer preferences
                */
                // Iterate all options and save into customerpricingoptioninputs
                foreach (var popt in poptions) {
                    if (Request[popt.PricingOptionName + "-check"] == "true") {
                        // Value to set can be null for options without quantity/value (only check), that cases
                        // we set value '1'
                        db.Execute(LcData.sqlSetCustomerPricingOption, Request[popt.PricingOptionName] ?? 1, c.UserID, popt.PricingOptionID);
                    } else {
                        db.Execute(LcData.sqlDelCustomerPricingOption, c.UserID, popt.PricingOptionID);
                    }
                }
                
                /* Save data into the pricingestimate tables
                 */
                foreach (var popt in poptions) {
                    if (Request[popt.PricingOptionName + "-check"] == "true") {
                        // Get pair time and price
                        decimal[] timeprice = pricingOptionsNumbers[popt.PricingOptionID];
                        // Insert data:
                        db.Execute(LcData.Booking.sqlInsEstimateDetails, 
                            PageData["EstimateID"], PageData["RevisionID"],
                            0, 0,
                            popt.PricingOptionID,
                            popt.ServiceAttributeID,
                            0,
                            popt.ProviderDataInputValue,
                            Request[popt.PricingOptionName] ?? 1,
                            0, // systemPricingDataInput
                            0, // hourlyRate (options are not calculated based on a hourly rate, save 0)
                            timeprice[0], timeprice[1]);
                    }
                }
                dataSaved = 0; // saved successfully
            }
        }
        
        if (embMode == "none") {
            LcHelpers.ReturnJsonResult(0, LcRessources.DataSaved);
        } else {
            LcHelpers.RenderPageReturns = new Dictionary<string, object> {
                { "CalculatedData", calculatedData },
                { "SavedCode", dataSaved }
            };
        }
    }
}
@helper getChecked(string name, string value, dynamic poptvar){
    // Get checked if was setted by form of is was previously setted at database
    if (IsPost) {
        @Html.Raw((Request[name] == value) ? "checked='checked'" : "")
    } else {
        @Html.Raw(poptvar.CustomerDataInputValue != null ? "checked='checked'" : "")
    }
}
@helper getSelected(string name, string value, dynamic poptvar){
    if (IsPost) {
        @Html.Raw(Request[name] == value ? "selected='selected'" : "");
    } else {
        @Html.Raw(poptvar.CustomerDataInputValue == value ? "selected='selected'" : "");
    }
}
@if (embMode != "back-end" && embMode != "calculate") {
    LcHelpers.RenderPageReturns = new Dictionary<string, object>() {
        { "OptionsCount", poptions.Count }
    };
    if (poptions.Count > 0) {
        <table class="pricing-options calculate-items-totals calculate-summary-group" data-calculation-summary-group="options">
            <thead>
                <tr>
                    <th></th>
                    <th class="name">@tableTitle</th>
                    <th class="duration number">Duration</th>
                    <th class="number">Item Price</th>
                    <th class="number">Quantity</th>
                    <th class="number">Total Price</th>
                </tr>
            </thead>
            <tbody>
            @foreach (var popt in poptions)
            {
                <tr class="@popt.PricingOptionName data-type-@popt.CustomerDataInputType">
                    <td><input type="checkbox" class="calculate-item-checked" name="@popt.PricingOptionName-check" id="@idprefix-@popt.PricingOptionName-check" @getChecked(popt.PricingOptionName + "-check", "true", popt) value="true" /></td>
                    <td class="pricing-option-check name">
                        <label for="@idprefix-@popt.PricingOptionName-check">@popt.CustomerPricingOptionDisplayText</label>
                    </td>
                    <td class="pricint-option-duration duration">@popt.ProviderTimeRequired minutes</td>
                    <td class="pricing-option-item-price number money calculate-item-price">@popt.ProviderDataInputValue</td>
                    <td class="pricing-option-quantity number">
                    @switch ((string)@popt.CustomerDataInputType)
                    {
                        case "dropdown":
                            <select id="@idprefix-@popt.PricingOptionName" name="@popt.PricingOptionName" class="calculate-item-quantity">
                                @{
                                    var optvalues = LcHelpers.GetValuesFromCSVLine(popt.CustomerDataValues);
                                    foreach (string optv in optvalues)
                                    {
                                        var v = optv.Trim();
                                        <option value="@v" @getSelected(popt.PricingOptionName, v, popt)>@v</option>
                                    }
                                 }
                            </select>
                            break;
                        case "number":
                        case "text":
                            <input type="text" class="calculate-item-quantity" id="@idprefix-@popt.PricingOptionName" name="@popt.PricingOptionName" value="@(Request[popt.PricingOptionName] ?? popt.CustomerDataInputValue)"/>
                            break;
                        case "":
                            <text>N/A</text>
                            break;
                        default:
                            <text>Unknown CustomerDataInputType: @popt.CustomerDataInputType</text>
                            break;
                    }
                    </td>
                    <td class="pricing-option-total-price calculated number money">
                        <span class="calculate-item-total">@((optionalServicesPrices.ContainsKey(popt.PricingOptionID) ? optionalServicesPrices[popt.PricingOptionID] : 0).ToString("c"))</span>
                    </td>
                </tr>
            }
            </tbody>
        </table>
    }
}