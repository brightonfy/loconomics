@using WebMatrix.Data;
@{
    LcHelpers.SecurePage();
    
    var p = PageData["providerrow"] ?? LcData.UserInfo.GetUserRow(Request["providerid"].AsInt());
    var c = PageData["customerrow"] ?? LcData.UserInfo.GetUserRow();
    var pos = PageData["positionrow"] ?? LcData.UserInfo.GetUserPos(Request["providerid"].AsInt(),
        Request["positionid"].AsInt());
    DateTime dt1Start, dt1End, dt2Start, dt2End, dt3Start, dt3End;
    dt1Start = dt1End = dt2Start = dt2End = dt3Start = dt3End = DateTime.MinValue;
    
    if (p == null || c == null || pos == null){
        var inputdataerrormessage = "No enought input data to show results";
        if (IsPost){
            LcHelpers.ReturnJsonError(-1, inputdataerrormessage);
        }else{
            throw new Exception(inputdataerrormessage);
        }
    }
    
    /* NOTE: from 20120906, issue #117, end times are automatically calculated, no more selected by customer */
    Validation.RequireField("preferred-date", "Must specify a preferred date");
    Validation.RequireField("preferred-start-time", "Must specify a preferred start time");
    //Validation.RequireField("preferred-end-time", "Must specify a preferred end time");
    Validation.RequireField("alternative-1-date", "Must specify a second date");
    Validation.RequireField("alternative-1-start-time", "Must specify a second start time");
    //Validation.RequireField("alternative-1-end-time", "Must specify a second end time");
    Validation.RequireField("alternative-2-date", "Must specify a third date");
    Validation.RequireField("alternative-2-start-time", "Must specify a third start time");
    //Validation.RequireField("alternative-2-end-time", "Must specify a third end time");
    Validation.Add("preferred-date", Validator.DateTime("Preferred date format is invalid"));
    Validation.Add("alternative-1-date", Validator.DateTime("Alternative 1 format is invalid"));
    Validation.Add("alternative-2-date", Validator.DateTime("Alternative 2 format is invalid"));
    Validation.Add("select-location", Validator.Integer("Invalid selected location"));
    // TODO: create validators for only dates and only time and add for start-time, end-time and dates

    // Check if is a valid booking process (session not expired or error at first step)
    var bookingRequestID = Session["BookingRequestID"] is int ? (int)Session["BookingRequestID"] : 0;
    if (bookingRequestID <= 0) {
        /* Several options to do here
            * - Show error (strange message for user, need restart again introducing first his login)
            * X Silently redirect to start booking again
            * - Request login via ajax, re-send form data, looking in the database for a 'timeouted'
            *   bookingrequest for this customer at this provider and position, recover it to continue
            *   processing the form (if there is no bookingrequestid again, do second option).
            */
        //ModelState.AddFormError("Booking request is not valid, maybe the session time expired");
        LcHelpers.ReturnJsonResult(1, 
            UrlUtil.LangPath + "Booking/?ProviderID=" + p.UserID.ToString() +
            "&PositionID=" + pos.PositionID.ToString());
    }
    
    if (IsPost && Validation.IsValid()){
        
        var zipcodeID = 0;
        // Check if a location was selected or new location must be validated:
        int locationID = Request["select-location"].AsInt();
        if (Request["select-location"].IsEmpty()) {
            ModelState.AddFormError("You must specify a location");
        } else if (locationID == 0) {
            if (Request["street-address-line-1"].IsEmpty()) {
                ModelState.AddError("street-address-line-1", "The street address is required");
            }
            if (Request["city"].IsEmpty()) {
                ModelState.AddError("city", "The city is required");
            }
            if (Request["state"].IsEmpty()) {
                ModelState.AddError("state", "The state is required");
            }
            if (Request["zip"].IsEmpty()) {
                ModelState.AddError("zip", "The Zip Code is required");
            } else if (!Request["zip"].IsInt()) {
                ModelState.AddError("zip", "The Zip Code must be a number");
            }
            zipcodeID = LcData.GetPostalCodeID(Request["zip"], Request["state"].AsInt());
            if (zipcodeID == 0) {
                ModelState.AddError("tin_zipcode", "Zip code is not valid");
            }
        }
        
        if (Request["save-location"] == "true" && Request["save-location-as"].IsEmpty()){
            ModelState.AddError("save-location-as", "To save the location is required a name");
        }
        
        /* NOTE: from 20120906, issue #117, end times are automatically calculated, no more selected by customer */
        if (!DateTime.TryParse(
                Request["preferred-date"] + " " + Request["preferred-start-time"], out dt1Start)) {
            ModelState.AddFormError("Preferred Date and Start Time are not correct");
        }
        /*if (!DateTime.TryParse(
                Request["preferred-date"] + " " + Request["preferred-end-time"], out dt1End)) {
            ModelState.AddFormError("Preferred Date and End Time are not correct");
        }*/
        if (!DateTime.TryParse(
                Request["alternative-1-date"] + " " + Request["alternative-1-start-time"], out dt2Start)) {
            ModelState.AddFormError("Second best Date and Start Time are not correct");
        }
        /*if (!DateTime.TryParse(
                Request["alternative-1-date"] + " " + Request["alternative-1-end-time"], out dt2End)) {
            ModelState.AddFormError("Second best Date and End Time are not correct");
        }*/
        if (!DateTime.TryParse(
                Request["alternative-2-date"] + " " + Request["alternative-2-start-time"], out dt3Start)) {
            ModelState.AddFormError("Third best Date and Start Time are not correct");
        }
        /*if (!DateTime.TryParse(
                Request["alternative-2-date"] + " " + Request["alternative-2-end-time"], out dt3End)) {
            ModelState.AddFormError("Third best Date and End Time are not correct");
        }*/
        
        // Validate provider availability with requested dates
        var sqlCheckAvail = "exec dbo.CheckProviderAvailability @0,@1,@2";
        using (var db = Database.Open("sqlloco")) {
            decimal durationHours = getServiceDurationHours(db, bookingRequestID, p.UserID);
            dt1End = dt1Start.AddHours((double)durationHours);
            dt2End = dt2Start.AddHours((double)durationHours);
            dt3End = dt3Start.AddHours((double)durationHours);
            
            if (dt1Start != null) {
                if ((bool)db.QueryValue(sqlCheckAvail, p.UserID, dt1Start, dt1End)) {
                    ModelState.AddFormError("The provider is not availaible for the Prefered Date");
                }
            }
            if (dt2Start != null) {
                if ((bool)db.QueryValue(sqlCheckAvail, p.UserID, dt2Start, dt2End)) {
                    ModelState.AddFormError("The provider is not availaible for the Second best Date");
                }
            }
            if (dt3Start != null) {
                if ((bool)db.QueryValue(sqlCheckAvail, p.UserID, dt3Start, dt3End)) {
                    ModelState.AddFormError("The provider is not availaible for the Third best Date");
                }
            }
        }
        
        if (ModelState.IsValid){
            
            // NOTE: as of 20120906 issue #117, events are not created on database on form-post else are saved in memory until the
            // booking process finish it, to avoid 'dead tentative events' exist in the database.
            // Save calculated datetimes in session to last step
            Dictionary<int, Dictionary<string, DateTime>> brs = null;
            if (Session["BookingRequests"] == null) {
                Session["BookingRequests"] = brs = new Dictionary<int, Dictionary<string, DateTime>>();
            } else {
                brs = (Dictionary<int, Dictionary<string, DateTime>>)Session["BookingRequests"];
            }
            brs[bookingRequestID] = new Dictionary<string, DateTime> {
                { "dt1Start", dt1Start }
                ,{ "dt1End", dt1End }
                ,{ "dt2Start", dt2Start }
                ,{ "dt2End", dt2End }
                ,{ "dt3Start", dt3Start }
                ,{ "dt3End", dt3End }
            };
            
            var sqlUpdBookingRequest = @"
                UPDATE  BookingRequest SET
                        AddressID = @1
                WHERE   BookingRequestID = @0
            ";
            
            // Inserting data into the database
            using (var db = Database.Open("sqlloco")) {
                // If we have not a location (is 0), means user specify one
                // that must be saved:
                if (locationID == 0) {
                    // User wants to save as 'my location'?
                    string locationNickName = null;
                    if (Request["save-location"] == "true" &&
                        !String.IsNullOrWhiteSpace(Request["save-location-as"])) {
                        locationNickName = Request["save-location-as"];
                    }
                    // Save location as service location
                    locationID = db.QueryValue(LcData.sqlSetServiceAddress,
                        0, // AddressID:0, new address to be inserted
                        c.UserID,
                        Request["street-address-line-1"],
                        Request["street-address-line-2"],
                        Request["city"],
                        Request["state"],
                        zipcodeID,
                        LcData.GetCurrentCountryID(),
                        locationNickName,
                        12 /*AddressType: Other*/,
                        null, /* special instructions */
                        null, null, null, /* latitude, longitude, googlemapsurl */
                        0 /*Position Zero, customer*/,
                        true /*Service performed at this location*/,
                        false,
                        null,
                        null,
                        false);
                }
                
                // Updating BookingRequest with location and date-times
                db.Execute(sqlUpdBookingRequest, bookingRequestID,
                    locationID);
            }
            
            // Return OK result
            LcHelpers.ReturnJsonResult(0, null);
        }
    }
    
    /*
     * Loading some data:
     */
    dynamic providerLocations, customerLocations;
    decimal serviceDurationHours = 0;
    using (var db = Database.Open("sqlloco")) {
        // Provider locations
        providerLocations = db.Query(@"
            SELECT  DISTINCT L.AddressID, L.AddressName
            FROM    ServiceAddress As SA
                     INNER JOIN
                    Address As L
                      ON L.AddressID = SA.AddressID
            WHERE   L.UserId = @0 AND SA.PositionID = @1
                     AND L.AddressName IS NOT NULL
                     AND SA.ServicesPerformedAtLocation = 1
        ", p.UserID, pos.PositionID);
        // Customer locations
        customerLocations = db.Query(@"
            SELECT  DISTINCT L.AddressID, L.AddressName
            FROM    Address As L
            WHERE   L.UserId = @0
                     AND L.AddressName IS NOT NULL
        ", c.UserID);
        serviceDurationHours = getServiceDurationHours(db, bookingRequestID, p.UserID);
    }
}
@functions { 
    decimal getServiceDurationHours(Database db, int bookingRequestID, int providerID) {
        decimal serviceDurationHours = (decimal)db.QueryValue(@"
            SELECT  TOP 1 coalesce(max(P.ServiceDuration), 0)
            FROM    BookingRequest As R
                     INNER JOIN
                    PricingEstimate As P
                      ON R.PricingEstimateID = P.PricingEstimateID
            WHERE   R.BookingRequestID = @0
        ", bookingRequestID);
        decimal minHours = (decimal)db.QueryValue(@"
            SELECT  TOP 1 coalesce(max(MinTime), 0)
            FROM    CalendarProviderAttributes
            WHERE   UserID = @0
        ", providerID);
        // Never be lower than minimum
        serviceDurationHours = (serviceDurationHours < minHours ? minHours : serviceDurationHours);
        // Default duration 4 hours, if there is no info about it
        return (serviceDurationHours == 0M ? 4M : serviceDurationHours);
    }
}
@helper printOptionsHours(string selectedHour){
    var firstHour = new TimeSpan(7, 0, 0);
    var lastHour = new TimeSpan(22, 30, 0);
    var interval = new TimeSpan(0, 30, 0);
    <option @LcHelpers.IsSelected(selectedHour, "") value=""></option>
    for (var hour = firstHour; hour <= lastHour; hour += interval)
    {
        string thisvalue = hour.ToString("c");
        <option @LcHelpers.IsSelected(selectedHour, thisvalue) value="@thisvalue">@((new DateTime(hour.Ticks)).ToShortTimeString())</option>
    }
}

<p class="info">
    Please review your provider’s availability calendar and choose a location, preferred time for services to be peformed and up to two alternate times.  Being flexible helps the two of you get an accurate time booked quickly.  
</p>
<form action="@(UrlUtil.LangPath)Booking/$Schedule/" method="post" class="schedule" id="booking-schedule">
    <input type="hidden" name="providerid" value="@p.UserID"/>
    <input type="hidden" name="positionid" value="@pos.PositionID"/>
    @LcHelpers.GetValidationScripts()
    @Html.ValidationSummary(LcRessources.ValidationSummaryTitle)
    <script type="text/javascript">
        if (!serviceDurationHours) var serviceDurationHours = 0;
        serviceDurationHours = @(serviceDurationHours);
        @if (IsPost) {
            <text>applyDatePicker();</text>
        }
    </script>
    <fieldset class="availability availability-calendar box">
        <legend>@(p.FirstName)'s availability:</legend>
        @RenderPage(UrlUtil.LangPath + "Profile/$AvailabilityCalendarWidget.cshtml", new Dictionary<string, object>{ { "AvailabilityCalendar.UserID", p.UserID }, { "AvailabilityCalendar.HasWrapper", false}, { "AvailabilityCalendar.HasZoom", true } } )
    </fieldset>
    <fieldset class="location box">
        <legend>Location where services are to be performed:</legend>
        <select name="select-location" class="select-location">
            <option value="" @LcHelpers.IsSelected(Request["select-location"], "")>Select a location</option>
            <option value="0" @LcHelpers.IsSelected(Request["select-location"], "0")>Enter new location</option>
            @if (providerLocations != null && providerLocations.Count > 0) {
                <optgroup label="Provider perform services at following locations">
                    @foreach (var ploc in providerLocations) {
                        <option @LcHelpers.IsSelected(Request["select-location"], ploc.AddressID) value="@ploc.AddressID">@ploc.AddressName</option>
                    }
                </optgroup>
            }
            @if (customerLocations != null && customerLocations.Count > 0) {
                <optgroup label="Your locations">
                    @foreach (var ploc in customerLocations) {
                        <option @LcHelpers.IsSelected(Request["select-location"], ploc.AddressID) value="@ploc.AddressID">@ploc.AddressName</option>
                    }
                </optgroup>
            }
        </select>
        <ul class="enter-new-location" style="display: none">
            <li class="street-address-line-1">
                <label>Street address line 1:<input type="text" value="@Request["street-address-line-1"]" name="street-address-line-1" @Validation.GetHtml("street-address-line-1")/></label>
            </li>
            <li class="street-address-line-2">
                <label>Street address line 2:<input type="text" value="@Request["street-address-line-2"]" name="street-address-line-2" @Validation.GetHtml("street-address-line-2")/></label>
            </li>
            <li class="city">
                <label>City:<input type="text" value="@Request["city"]" name="city" @Validation.GetHtml("city")/></label>
            </li>
            <!-- Collapsed next elements code to avoid white spaces that create excesive width on IE -->
            <li class="state"><label>State:<select name="state" @Validation.GetHtml("state")>
                        @LcHelpers.StateProvinceOptions(Request["state"].AsInt())
                    </select></label></li>
            <li class="zip">
                <label>Zip Code:<input type="text" data-val-postalcode="Postal Code is not valid" value="@Request["zip"]" name="zip" @Validation.GetHtml("zip")/></label>
            </li>
            <li class="save-to-my-locations">
                <label class="save"><input type="checkbox" @LcHelpers.IsChecked(Request["save-location"], "true") value="true" name="save-location"/>Save</label>
                <label>to my locations as:<input type="text" value="@Request["save-location-as"]" name="save-location-as" @Validation.GetHtml("save-location-as")/></label>
            </li>
        </ul>
    </fieldset>
    <fieldset class="select-schedule">
        <fieldset class="preferred-option select-date-time box">
            <legend>My preferred option:</legend>
            <ul>
                <li class="date">
                    <label>Date:<input class="date date-pick" type="text" value="@Request["preferred-date"]" name="preferred-date" @Validation.GetHtml("preferred-date")/></label>
                </li>
                <li class="start-time">
                    <label>Start time:<select name="preferred-start-time" @Validation.GetHtml("preferred-start-time")>@printOptionsHours(Request["preferred-start-time"])</select></label>
                </li>
                <li class="end-time">
                    <label>End time:<input type="text" readonly="readonly" value="@(IsPost ? dt1End.ToShortTimeString() : "")" /></label>
                </li>
            </ul>
        </fieldset>
        <fieldset class="alternative-option-1 select-date-time box">
            <legend>Second best option:</legend>
            <ul>
                <li class="date">
                    <label>Date:<input class="date date-pick" type="text" value="@Request["alternative-1-date"]" name="alternative-1-date" @Validation.GetHtml("alternative-1-date")/></label>
                </li>
                <li class="start-time">
                    <label>Start time:<select name="alternative-1-start-time" @Validation.GetHtml("alternative-1-start-time")>@printOptionsHours(Request["alternative-1-start-time"])</select></label>
                </li>
                <li class="end-time">
                    <label>End time:<input type="text" readonly="readonly" value="@(IsPost ? dt2End.ToShortTimeString() : "")" /></label>
                </li>
            </ul>
        </fieldset>
        <fieldset class="alternative-option-2 select-date-time box">
            <legend>Third best option:</legend>
            <ul>
                <li class="date">
                    <label>Date:<input class="date date-pick" type="text" value="@Request["alternative-2-date"]" name="alternative-2-date" @Validation.GetHtml("alternative-2-date")/></label>
                </li>
                <li class="start-time">
                    <label>Start time:<select name="alternative-2-start-time" @Validation.GetHtml("alternative-2-start-time")>@printOptionsHours(Request["alternative-2-start-time"])</select></label>
                </li>
                <li class="end-time">
                    <label>End time:<input type="text" readonly="readonly" value="@(IsPost ? dt3End.ToShortTimeString() : "")" /></label>
                </li>
            </ul>
        </fieldset>
        @*
        <fieldset class="recurring">
            <label><input type="checkbox" @LcHelpers.IsChecked(Request["recurring"], "true") value="true" name="recurring"/>Make this appointment recurring</label>
        </fieldset>
        *@
    </fieldset>
    <fieldset class="actions">
        <button data-wizard-next-step="#payment" class="proceed-to-payment next main-action">Provide payment</button>
    </fieldset>
</form>
