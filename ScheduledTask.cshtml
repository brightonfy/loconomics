@using WebMatrix.Data;
@using System.Text;
@{
    var logger = PageData["Logger"] = new StringBuilder();
    var elapsedTime = DateTime.Now;

    var total = 0;
    using(var db = Database.Open("sqlloco")){
        /*
         * Checking timedouts booking requests and invalide.
         * Check:: Booking Request timed out
         * If:: A not complete booking request exist without changes from more than 1 day
         * Action:: Set as timedout, invalidating the request and its data
         */
        total = 0;
        foreach (var br in db.Query(@"
                SELECT  BookingRequestID
                FROM    BookingRequest
                WHERE   BookingRequestStatusID = 1 -- created but not completed
                         AND
                        -- is old enought to be considered not active
                        UpdatedDate < dateadd(d, -1, getdate())
            ")){
            try {
                // RequestStatusID:3:timed out
                LcData.Booking.InvalidateBookingRequest(br.BookingRequestID, 3);
                total++;
            } catch (Exception ex){
                logEx("Requests Timed-out", ex);
            }
        }
        log("Total invalidated as TimedOut Booking Requests: {0}", total);
        
        /*
         * Check:: Booking Request expiration
         * If:: Provider didn't reply
         * If:: Request not updated/changed
         * Action:: Set as expired, un-authorize/return money to customer, notify
         */
        total = 0;
        foreach (var br in db.Query(@"
                SELECT  BookingRequestID
                FROM    BookingRequest
                WHERE   BookingRequestStatusID = 2 -- request created and completed, without provider answer
                         AND
                        -- passed 18 hours from request or some change (some provider communication or customer change)
                        UpdatedDate < dateadd(hh, -18, getdate())
            ")){
            try {
                // RequestStatusID:6:expired
                var result = LcData.Booking.InvalidateBookingRequest(br.BookingRequestID, 6);
                if (result.Error == 0) {
                    // Send message
                    LcMessaging.SendBookingRequestInvalidation(br.BookingRequestID, 1, 19);
                }
                
                total++;
            } catch (Exception ex){
                logEx("Requests Expired", ex);
            }
        }
        log("Total invalidated as Expired Booking Requests: {0}", total);
        
        /*
         * Check:: 24H Booking Reminder
         * If:: Confirmated bookings not cancelled
         * If:: Current time is 24 hours before Confirmed Service DateTime
         * Action:: send a booking reminder email
         */
        total = 0;
        foreach (var b in db.Query(@"
                SELECT  BookingID
                FROM    Booking As B
                         INNER JOIN
                        CalendarEvents As E
                          ON B.ConfirmedDateID = E.Id
                WHERE   BookingStatusID = 1 -- confirmed, not cancelled and not other changes
                         AND
                        -- at 24 hours from request (between 25 and 24 hours)
                        getdate() > dateadd(hh, -25, E.StartTime)
                         AND
                        getdate() <= dateadd(hh, -24, E.StartTime)
            ")){
            try {
                // Send message
                // TODO: Send a more specific reminder message, instead a simple copy of
                // current booking state
                LcMessaging.SendBookingUpdate(b.BookingID, 's');

                total++;
            } catch (Exception ex){
                logEx("Booking 24H Reminders", ex);
            }
        }
        log("Total of Booking 24H Reminders sent: {0}", total);
        
        /*
         * Check:: Booking Review Reminder
         * If:: Confirmated bookings not cancelled
         * If:: Current time is 8AM on the day after the Confirmed Service DateTime
         * Action:: send a booking review reminder email
         */
        total = 0;
        foreach (var b in db.Query(@"
                SELECT  BookingID
                FROM    Booking As B
                         INNER JOIN
                        CalendarEvents As E
                          ON B.ConfirmedDateID = E.Id
                WHERE   BookingStatusID = 1 -- confirmed, not cancelled and not other changes
                         AND
                        -- at 8AM hours
                        datepart(hh, getdate()) = 8
                         AND
                        -- of the day after the service
                        Cast(dateadd(d, -1, getdate()) As Date) = Cast(E.StartTime As Date)
            ")){
            try {
                // Send message
                // TODO: Send a more specific reminder message, instead a simple copy of
                // current booking state (that at this moment must show the review button)
                LcMessaging.SendBookingUpdate(b.BookingID, 's');

                total++;
            } catch (Exception ex){
                logEx("Booking Review Reminders", ex);
            }
        }
        log("Total of Booking Review Reminders sent: {0}", total);
    }
    
    log("Elapsed time for this last tasks batch: {0}", DateTime.Now - elapsedTime);
    
    // Finishing: save log on disk
    try {
        System.IO.File.AppendAllText(Server.MapPath(UrlUtil.RenderAppPath + "_logs/ScheduledTaskLog.txt"), logger.ToString());
    }catch {
    }
}
@functions{
    void log(string format, params object[] pars){
        StringBuilder logger = PageData["Logger"];
        // Universal date-time, following ISO8601 format with Z identifier at the end
        logger.AppendFormat("{0:s}Z ", DateTime.Now.ToUniversalTime());
        logger.AppendFormat(format, pars);
        logger.Append("\n");
    }
    void logEx(string task, Exception ex){
        log("{1}: Exception {2}\n", task, ex.Message);
    }
}
@if (!LcHelpers.InProduction)
{
    Response.ContentType = "text/plain";
    @logger.ToString()
}
